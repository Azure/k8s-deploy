"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeploymentReport = void 0;
const path = require("path");
const fs = require("fs");
const githubClient_1 = require("./clients/githubClient");
const httpClient_1 = require("./clients/httpClient");
class DeploymentReport {
    initialize(gitHubToken, artifacts, pipelineStatus, targetResource) {
        return __awaiter(this, void 0, void 0, function* () {
            this.artifacts = artifacts || [];
            this.targetResource = targetResource || null;
            this._githubClient = new githubClient_1.GitHubClient(process.env.GITHUB_REPOSITORY, gitHubToken);
            yield this.setPipeline(pipelineStatus || "");
        });
    }
    addArtifacts(artifacts) {
        if (artifacts) {
            this.artifacts = this.artifacts.concat(artifacts);
        }
    }
    setTargetResource(targetResource) {
        if (targetResource) {
            this.targetResource = targetResource;
        }
    }
    setPipeline(status) {
        return __awaiter(this, void 0, void 0, function* () {
            let timeStamp = new Date().toISOString();
            let workflowFilePath = yield this._getWorkflowFilePath();
            this.workflowRun = {
                provider: "GitHub",
                workflow: {
                    repository: `${process.env.GITHUB_REPOSITORY}`,
                    repositoryId: '',
                    name: `${process.env.GITHUB_WORKFLOW}`,
                    path: workflowFilePath,
                    ref: `${process.env.GITHUB_REF}`
                },
                runUri: `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`,
                createdBy: `${process.env.GITHUB_ACTOR}`,
                jobName: `${process.env.GITHUB_JOB}`,
                creationTimestamp: timeStamp,
                modifiedTimestamp: timeStamp,
                status: status,
                commit: `${process.env.GITHUB_SHA}`
            };
        });
    }
    export() {
        const deploymentReportPath = path.join(process.env['RUNNER_TEMP'], `deployment-report-${Date.now()}.json`);
        const report = {
            artifacts: this.artifacts,
            workflowRun: this.workflowRun,
            targetResource: this.targetResource
        };
        fs.writeFileSync(deploymentReportPath, JSON.stringify(report));
        return deploymentReportPath;
    }
    _getWorkflowFilePath() {
        return __awaiter(this, void 0, void 0, function* () {
            const workflowRunResponse = yield this._githubClient.getWorkflowRun(process.env.GITHUB_RUN_ID);
            let workFlowId = "";
            if (workflowRunResponse &&
                workflowRunResponse.statusCode === httpClient_1.StatusCodes.OK &&
                workflowRunResponse.body) {
                workFlowId = workflowRunResponse.body['workflow_id'];
            }
            else {
                console.log(`An error occurred while fetching run details. StatusCode: ${workflowRunResponse.statusCode}, Error: ${workflowRunResponse.statusMessage}`);
                return Promise.resolve("");
            }
            const workflowResponse = yield this._githubClient.getWorkflow(workFlowId);
            if (workflowResponse &&
                workflowResponse.statusCode === httpClient_1.StatusCodes.OK &&
                workflowResponse.body) {
                return Promise.resolve(workflowResponse.body['path']);
            }
            else {
                console.log(`An error occurred while fetching workflow details. StatusCode: ${workflowResponse.statusCode}, Error: ${workflowResponse.statusMessage}`);
                return Promise.resolve("");
            }
        });
    }
}
exports.DeploymentReport = DeploymentReport;
